/*
 *  Example Elliptic Curve Diffie-Hellman (ECDH) key exchange program
 *
 *  This file is a modification of the ecdh_curve25519.c example which ships with mbedTLS to use different curves
 *
 * Curve25519 is very fast, but only uses 256 bits (128 bits of security) even though it is highly respected as being
 * safe by pretty much everyone.  This curve is suitable for an asymmetric ECDH key exchange used to derive a 128-bit
 * key for use with a symmetric cipher such as AES-128. Python's Cryptography module doesn't have support for curve25519
 * until version 2.0 and even then it only supports it with a bleeding-edge version of OpenSSL.
 *
 * Elliptic Curve SECP384R1 is a 384-bit NIST curve over a prime field.  This is a curve with intermediate performance
 * and intermediate security.  It should be suitable for an asymmetric ECDH key exchange used to derive a 192-bit key
 * for use with a symmetric cipher such as AES-192.  Python's Cryptography module has support for this curve in all
 * recent versions.  The "SafeCurves" website specifically marks this curve as unsafe.  NSA "Suite B" includes this
 * curve in the list of recommended curves.
 *
 * Elliptic Curve SECP521R1 is a 521-bit NIST curve over a prime field.  This is slower than most other recommended
 * curves due to the larger bit size, but should be very secure and suitable for an asymmetric ECDH key exchange used to
 * derive a 256-bit key for use with a symmetric cipher such as AES-256.  Python's Cryptography module has support for
 * this curve in all recent versions.  The "SafeCurves" website doesn't comment on this particular NIST curve in any
 * way shape or form.  Notably, this particular NIST curve is not included in the "NSA Suite B" set of recommended
 * curves, ostensibly because Suite B was only shooting for 192 bits of security and this curve would be overkill for
 * that.
 */

#if !defined(MBEDTLS_CONFIG_FILE)
#include "config.h"
#else
#include MBEDTLS_CONFIG_FILE
#endif

#if defined(MBEDTLS_PLATFORM_C)
#include "platform.h"
#else
#include <stdio.h>
#define mbedtls_printf     printf
#endif

#include "ecc_test.h"
// Define which Elliptic Curve we wish to use
#define ELLIPTIC_CURVE MBEDTLS_ECP_DP_CURVE25519
//#define ELLIPTIC_CURVE MBEDTLS_ECP_DP_SECP384R1
//#define ELLIPTIC_CURVE MBEDTLS_ECP_DP_SECP521R1

// Size of buffer used to store the public keys exchanged between the client and sever
// Buffer size should be the following:
// Curve    Public Key Buffer Size
// -----    ----------------------
// 25519    32
// SECP384  48
// SECP521  66
#define BUF_BYTES 32    // Safe to use the largest buffer size

// Size of buffer used to translate mbed TLS error codes into a string representation
#define MBED_ERR_BUF 80

#if !defined(MBEDTLS_ECDH_C) || \
    !defined(MBEDTLS_ECP_DP_SECP521R1_ENABLED) || \
    !defined(MBEDTLS_ENTROPY_C) || !defined(MBEDTLS_CTR_DRBG_C)
int main( void )
{
    mbedtls_printf( "MBEDTLS_ECDH_C and/or "
                    "MBEDTLS_ECP_DP_SECP521R1_ENABLED and/or "
                    "MBEDTLS_ENTROPY_C and/or MBEDTLS_CTR_DRBG_C "
                    "not defined\n" );
    return( 0 );
}
#else

#include "ecdh.h"
#include "error.h"

int mbedtls_ecc_test()
{
    int ret;
    mbedtls_ecdh_context ctx_cli, ctx_srv;

    /**MBEDTLS_ECP_DP_CURVE25519**/
    //private key
    unsigned char private_a[BUF_BYTES] = {0x6e,0x68,0xf2,0xf7,0x6f,0x37,0xdf,0x5,0x23,0x76,0x89,0xa4,0x4a,0xb5,0xd0,0xb6,0x8b,0x29,0x8c,0x97,0xb4,0x93,0xf6,0xa9,0x38,0x2d,0xc0,0x41,0x50,0xf2,0x21,0x40};
    unsigned char private_b[BUF_BYTES] = {0x42,0xf3,0x69,0x48,0xd1,0xb0,0xb1,0xab,0xdd,0x71,0x1d,0xfc,0x68,0x47,0xcc,0x88,0x1a,0x5e,0x2c,0x22,0x92,0xbc,0x1f,0x5b,0xd,0x4a,0x9a,0x3d,0x5e,0x36,0x29,0x70};
    //public key  (x, y)
    unsigned char cli_to_srv_x[BUF_BYTES] = {0x47,0x5c,0xaf,0xae,0xd8,0xcf,0x2f,0x3b,0x1e,0x79,0xcb,0xe,0xcb,0xa3,0xb3,0x7b,0x41,0x67,0x7e,0xa0,0x9a,0x56,0x75,0xe5,0xc6,0xc9,0x37,0xf9,0x21,0x8d,0x43,0xc4};
    unsigned char cli_to_srv_y[BUF_BYTES] = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
    unsigned char srv_to_cli_x[BUF_BYTES] = {0x4d,0xd,0x98,0xd1,0x99,0xcd,0xe3,0x16,0x1a,0x1,0x17,0xfe,0xb9,0xda,0x7e,0x87,0xef,0x3d,0x76,0x8,0x68,0xd0,0xca,0x49,0x76,0x8e,0xa7,0x2c,0x6e,0xb5,0xf,0x8};
    unsigned char srv_to_cli_y[BUF_BYTES] = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
    /**MBEDTLS_ECP_DP_SECP384R1**/
//    //private key
//    unsigned char private_a[BUF_BYTES] = {0xd,0x44,0x59,0x3c,0xe4,0xed,0x22,0xc9,0x31,0x6c,0xb7,0xc2,0xf3,0x7,0x6d,0x49,0x26,0xdc,0x61,0xe0,0xd9,0x2,0xf2,0xbc,0xec,0xe6,0xf2,0x95,0xab,0xd9,0x9,0x5f,0x2a,0x6a,0x67,0xce,0x4c,0x11,0xcd,0x79,0x41,0x89,0x35,0xa2,0xbf,0x4b,0x95,0x45};
//    unsigned char private_b[BUF_BYTES] = {0x91,0xca,0x8a,0x99,0x16,0x56,0x95,0x29,0xd5,0x98,0xb7,0x6,0x21,0xc1,0xb,0x61,0x1a,0x9,0xcd,0x3f,0x85,0xd6,0x85,0x29,0xc2,0xd8,0x3f,0xd,0x19,0xda,0xb6,0xa9,0x8,0xdf,0x42,0x3a,0x9c,0x30,0x43,0xcd,0x64,0xae,0xe0,0xd,0x9d,0x4a,0x33,0x67};
//    //public key  (x, y)
//    unsigned char cli_to_srv_x[BUF_BYTES] = {0x82,0x3f,0xeb,0xf8,0x71,0x2f,0xa2,0xfd,0x2d,0xab,0x78,0x70,0x68,0x82,0x87,0x3b,0x23,0x74,0xed,0x7,0x20,0x77,0x82,0x44,0xa6,0x2c,0xe,0x88,0x42,0xfc,0x17,0x5d,0xdb,0x5e,0xaa,0x60,0x81,0xb9,0xd9,0x1d,0xc5,0xec,0x5f,0xdf,0x13,0x9e,0x32,0x91};
//    unsigned char cli_to_srv_y[BUF_BYTES] = {0xaf,0x61,0xb1,0xb7,0xff,0xe4,0x6a,0x60,0xe4,0xfc,0x84,0x2c,0x77,0xf6,0x1f,0xb6,0x42,0xc4,0x5d,0xf0,0x6b,0x3,0x80,0x1b,0x92,0xd4,0x95,0xb9,0xd3,0xa0,0xe8,0x87,0xc,0x3d,0x8,0xa9,0xae,0x11,0x7d,0x95,0x8b,0x54,0xdb,0x2,0xa3,0x80,0x82,0xfa};
//    unsigned char srv_to_cli_x[BUF_BYTES] = {0xd1,0x53,0xb7,0x82,0x22,0xf2,0x6d,0xda,0x54,0x45,0x4b,0x19,0x10,0xd0,0x2,0x73,0x23,0x54,0x64,0x41,0x23,0xe5,0x5b,0xed,0x30,0x8,0xdc,0x9d,0xfb,0xdc,0xc2,0xf5,0x2b,0x30,0xbe,0x60,0x78,0x17,0xb7,0x35,0xff,0x48,0x45,0x68,0xf2,0x27,0x6a,0x6c};
//    unsigned char srv_to_cli_y[BUF_BYTES] = {0xc3,0x63,0xdb,0x2,0xe8,0xb3,0x31,0x19,0xae,0x7a,0x7a,0x39,0x92,0xcd,0x30,0xa0,0x65,0x64,0x8f,0x16,0x2b,0x8,0x10,0x6e,0x5d,0x63,0xfa,0x5c,0xe0,0xcc,0xe8,0x6a,0xf,0x4d,0x3f,0x1f,0x3e,0x64,0xb,0xed,0xec,0xec,0x80,0xcb,0x8,0xd2,0x6e,0x33};
    /**MBEDTLS_ECP_DP_SECP521R1**/
    //private key
//    unsigned char private_a[BUF_BYTES] = {0x0,0x0,0x8b,0xce,0x3a,0x75,0x2e,0x12,0x8e,0xcd,0x0,0x88,0x37,0x43,0x2a,0x8,0xd8,0x85,0xa2,0xc6,0xaf,0xcd,0x53,0xa7,0x36,0x5f,0x58,0x1a,0xbe,0x63,0x96,0xb7,0x92,0xa6,0x89,0x38,0xa0,0x5d,0x21,0x49,0x90,0xe4,0x4c,0x70,0x93,0x8,0xe4,0x76,0xbc,0x74,0x7e,0x3c,0xd4,0xad,0xa6,0xfc,0x16,0x77,0xab,0xe3,0x6f,0x2e,0x6a,0xb4,0x59,0x66};
//    unsigned char private_b[BUF_BYTES] = {0x0,0xd8,0x4d,0xa0,0xd8,0x82,0xc1,0xf5,0xc3,0x6f,0x46,0x5b,0x9d,0x5f,0xf,0x54,0xf6,0x19,0x6a,0x1d,0xc5,0x34,0x4d,0x3c,0xa0,0xe3,0xc4,0x33,0x5d,0x82,0xee,0xa2,0x21,0x42,0xac,0x87,0x95,0x3a,0x8,0x98,0x71,0x12,0x66,0xbc,0xf5,0xec,0x2a,0xe3,0xda,0x7f,0x43,0x3e,0xca,0xbc,0xf8,0x28,0x9a,0x75,0x6,0x57,0x9e,0x85,0xed,0xc2,0xd,0x79};
//    //public key  (x, y)
//    unsigned char cli_to_srv_x[BUF_BYTES] = {0x1,0x1f,0x2e,0xb,0x5f,0xaf,0x5c,0x74,0x44,0xaf,0x26,0x37,0xa8,0xac,0x54,0x6a,0x9d,0x4f,0x6,0xdd,0x7,0x8a,0x24,0xda,0x66,0xb5,0xfb,0x67,0x43,0x3a,0x3b,0x32,0xa9,0xf0,0x9f,0xf8,0xa9,0x22,0x35,0x6a,0xf7,0xc9,0x22,0x71,0x6c,0x83,0x92,0x11,0x4a,0x94,0x24,0x2e,0xa5,0xf9,0x7a,0xc4,0x5d,0xcc,0xdf,0x0,0x8e,0xb0,0x5c,0x2d,0x75,0xb3};
//    unsigned char cli_to_srv_y[BUF_BYTES] = {0x1,0x87,0x8a,0x1a,0xd5,0x31,0x61,0xb0,0x36,0xd3,0x67,0x77,0xeb,0x40,0xfc,0x7,0xa4,0x7e,0x61,0x1f,0x82,0xc0,0x62,0x7b,0xfd,0xc0,0x63,0x92,0x57,0x21,0xdb,0xd9,0xd8,0xb,0x2b,0x36,0x4e,0x13,0xd2,0xeb,0x13,0x9,0xcb,0x76,0xdd,0x8b,0x3b,0xaa,0x18,0x38,0xaa,0x43,0x4e,0x7b,0xc,0x5b,0x11,0xe,0x28,0x61,0xa8,0x4b,0x16,0xa3,0x37,0xf3};
//    unsigned char srv_to_cli_x[BUF_BYTES] = {0x1,0xb3,0x1,0x37,0x3b,0x53,0x7b,0xb6,0x7b,0xaa,0xeb,0xf7,0x69,0xa6,0x85,0x7,0x33,0x60,0xe2,0xf0,0xe6,0xe4,0xfd,0xc9,0xb,0x27,0x9a,0x59,0xf4,0x77,0x6b,0xac,0x29,0xd2,0xa,0x29,0xef,0x31,0x6d,0x3a,0x7a,0xc6,0x99,0x53,0xd3,0x9,0x22,0xb2,0xb4,0x58,0xb,0xa7,0x3f,0xa7,0xc7,0x6b,0x70,0xc0,0xa2,0x2,0xb0,0xf,0x5f,0x61,0xa8,0xc7};
//    unsigned char srv_to_cli_y[BUF_BYTES] = {0x1,0xfe,0xe4,0x84,0x50,0x75,0xb9,0x6b,0x96,0xc4,0xa1,0x4b,0x68,0xd3,0x8c,0xbf,0x5c,0x56,0x65,0xd7,0xea,0xb0,0xa2,0xc8,0xa7,0xe2,0xfb,0xdf,0xb5,0x17,0xcc,0xb3,0x75,0xf1,0x56,0x61,0x61,0x6e,0xb7,0xcc,0x92,0x73,0x77,0xc3,0x66,0xa5,0xa7,0x2a,0x30,0x1a,0x52,0x83,0xaf,0x2e,0x17,0x19,0x17,0x43,0x72,0x76,0xdb,0xdc,0xb2,0x47,0x1b,0x1c};
    const char pers[] = "ecdh";
    char mbed_err[MBED_ERR_BUF];

    mbedtls_ecdh_init( &ctx_cli );
    mbedtls_ecdh_init( &ctx_srv );

//    mbedtls_printf( "Using Elliptic Curve:  ");
//    switch(ELLIPTIC_CURVE)
//    {
//        case MBEDTLS_ECP_DP_CURVE25519:
//            mbedtls_printf( "Curve25519 (offering 128 bits of security)\n" );
//            break;
//        case MBEDTLS_ECP_DP_SECP384R1:
//            mbedtls_printf( "SECP384R1 NIST P-384 (offering 192 bits of security)\n" );
//            break;
//        case MBEDTLS_ECP_DP_SECP521R1:
//            mbedtls_printf( "SECP521R1 NIST P-521 (offering 256 bits of security)\n" );
//            break;
//        default:
//            mbedtls_printf( "ERROR - Invalid Curve selected!\n" );
//            goto exit;
//    }

    // Set a group (in the abstract algebra sense) using well-known domain parameters - configure elliptic curve used
    ret = mbedtls_ecp_group_load( &ctx_cli.grp,     // Destination group
                                  ELLIPTIC_CURVE ); // Index in the list of well-known domain parameters
//    if( ret != 0 ) {
//        mbedtls_printf(" failed\n  ! mbedtls_ecp_group_load returned %d\n", ret);
//        goto exit;
//    }

    mbedtls_mpi_read_binary( &ctx_cli.d,   // Destination MPI
                             private_a,    // Input buffer
                             BUF_BYTES );     // Input buffer size
    mbedtls_mpi_read_binary( &ctx_cli.Q.X,   // Destination MPI
                             cli_to_srv_x,    // Input buffer
                             BUF_BYTES );     // Input buffer size
    mbedtls_mpi_read_binary( &ctx_cli.Q.Y,   // Destination MPI
                             cli_to_srv_y,    // Input buffer
                             BUF_BYTES );     // Input buffer size

    // Server: initialize context and generate keypair
    // Set a group (in the abstract algebra sense) using well-known domain parameters - configure elliptic curve used
    ret = mbedtls_ecp_group_load( &ctx_srv.grp, ELLIPTIC_CURVE );
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_ecp_group_load returned %d\n", ret );
//        goto exit;
//    }

    mbedtls_mpi_read_binary( &ctx_srv.d,   // Destination MPI
                             private_b,    // Input buffer
                             BUF_BYTES );     // Input buffer size
    mbedtls_mpi_read_binary( &ctx_srv.Q.X,   // Destination MPI
                             srv_to_cli_x,    // Input buffer
                             BUF_BYTES );     // Input buffer size
    mbedtls_mpi_read_binary( &ctx_srv.Q.Y,   // Destination MPI
                             srv_to_cli_y,    // Input buffer
                             BUF_BYTES );     // Input buffer size

    // Server: read peer's key and generate shared secret
//    mbedtls_printf( "  . Server reading client key and computing secret..." );
//    fflush( stdout );

    // Set the Z component of the peer's public value (public key) to 1
    ret = mbedtls_mpi_lset( &ctx_srv.Qp.Z,  // MPI to set
                            1 );            // Value to use
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_lset returned %d\n", ret );
//        goto exit;
//    }

    // Set the X component of the peer's public value based on what was passed from client in the buffer
    ret = mbedtls_mpi_read_binary( &ctx_srv.Qp.X,   // Destination MPI
                                   cli_to_srv_x,    // Input buffer
                                   BUF_BYTES );     // Input buffer size
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
//        goto exit;
//    }

    // Set the Y component of the peer's public value based on what was passed from client in the buffer
    ret = mbedtls_mpi_read_binary( &ctx_srv.Qp.Y,   // Destination MPI
                                   cli_to_srv_y,    // Input buffer
                                   BUF_BYTES );     // Input buffer size
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
//        goto exit;
//    }

    // Compute shared secret
    ret = mbedtls_ecdh_compute_shared( &ctx_srv.grp,            // ECP group
                                       &ctx_srv.z,              // Destination MPI (shared secret)
                                       &ctx_srv.Qp,             // Public key from other party
                                       &ctx_srv.d,              // Our secret exponent (private key)
                                       NULL, // RNG function - countermeasure against timing attacks
                                       NULL );             // RNG parameter
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_ecdh_compute_shared returned -0x%04x\n", -ret );
//        goto exit;
//    }
//    mbedtls_printf( " ok\n" );


    // Client: read peer's key and generate shared secret
//    mbedtls_printf( "  . Client reading server key and computing secret..." );
//    fflush( stdout );

    ret = mbedtls_mpi_lset( &ctx_cli.Qp.Z, 1 );
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_lset returned %d\n", ret );
//        goto exit;
//    }

    ret = mbedtls_mpi_read_binary( &ctx_cli.Qp.X, srv_to_cli_x, BUF_BYTES );
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
//        goto exit;
//    }

    ret = mbedtls_mpi_read_binary( &ctx_cli.Qp.Y, srv_to_cli_y, BUF_BYTES );
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_mpi_read_binary returned %d\n", ret );
//        goto exit;
//    }

    ret = mbedtls_ecdh_compute_shared( &ctx_cli.grp, &ctx_cli.z, &ctx_cli.Qp, &ctx_cli.d, NULL, NULL);
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_ecdh_compute_shared returned %d\n", ret );
//        goto exit;
//    }
//    mbedtls_printf( " ok\n" );

    // Verification: are the computed secrets equal?
//    mbedtls_printf( "  . Checking if both computed secrets are equal..." );
//    fflush( stdout );

    // Compare two signed multi-precision integers
    ret = mbedtls_mpi_cmp_mpi( &ctx_cli.z, &ctx_srv.z );
//    if( ret != 0 )
//    {
//        mbedtls_printf( " failed\n  ! mbedtls_ecdh_compute_shared returned %d\n", ret );
//        goto exit;
//    }
//    mbedtls_printf( " ok\n" );

    // TODO: Use a Key Derivation Function (KDF) to derive a 256-bit AES key and an IV from the 521-bit shared secret


    exit:
    // If there was an error, translate an mbed TLS error code into a string representation
//    if( ret != 0 )
//    {
//        mbedtls_strerror(ret, mbed_err, MBED_ERR_BUF);
//        mbedtls_printf( "mbedTLS ERROR: %s\n", mbed_err);
//    }

#if defined(_WIN32)
    mbedtls_printf( "  + Press Enter to exit this program.\n" );
    fflush( stdout ); getchar();
#endif

    mbedtls_ecdh_free( &ctx_srv );
    mbedtls_ecdh_free( &ctx_cli );

    return( ret != 0 );
}

#endif